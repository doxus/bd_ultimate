  % !TeX spellcheck = pl_PL
  \documentclass[a4paper,twoside]{article}
  \usepackage{polski}
  \usepackage[utf8]{inputenc}
  \usepackage{graphicx}
  \usepackage{amsmath}
  \usepackage{indentfirst}
  
  \usepackage[unicode, bookmarks=true]{hyperref} %do zakładek
  
  \graphicspath{ {./images/} }
  
  \setlength{\textheight}{24cm}
  \setlength{\textwidth}{15.92cm}
  \setlength{\footskip}{10mm}
  \setlength{\oddsidemargin}{0mm}
  \setlength{\evensidemargin}{0mm}
  \setlength{\topmargin}{0mm}
  \setlength{\headsep}{5mm}
  
  \setcounter{secnumdepth}{3}	%max numerowany poziom zagniezdzenia
  \setcounter{tocdepth}{3}	%uwzglednienie w spisie tresci
  
  \begin{document}
  	\bibliographystyle{plain}
  	
  	\begin{titlepage}
  		\title{\huge Bazy Danych II - ULTIMATE}
  		\author{\large SonMati \\ \large Doxus}
  		\maketitle
  	\end{titlepage}
  	
  	%===============================================================================
  	%*** PYTANIA I ODPOWIEDZI ******************************************************
  	%===============================================================================
  	\part*{Pytania i odpowiedzi}
  	% pytanie 1
  	\section{Co to jest ROWID?}
  	\begin{itemize}
  		\item[] \textbf{umożliwia identyfikację rekordu} \emph{tak, bo określa jednoznacznie wiersz w tabeli (a nawet jego wersję)}
  		\item[] \textbf{umożliwia wersjonowanie (wykrywanie modyfikacji)} \emph{tak, bo zmiany rekordu są w nim odnotowywane}
  		\item jest przeznaczony do tworzenia kluczy głównych
  		\item \textbf{jest w każdej tabeli} \emph{tak, bo jest po prostu w każdej tabeli xD}
  	\end{itemize}
  	
  	\section{W SQL Base realizacja fazy}
  	\begin{itemize}
  		\item \textbf{prepare - wysyłanie tekstu komendy do servera}
  		\item \textbf{execute - wysłanie zmiennych do servera}
  		\item execute - wypracowanie planu wykonania \emph{??to sobie sam serwer robi, a nie faza zapytania}
  		\item \textbf{prepare - sprawdzenie uprawnień usera do obiektów}
  	\end{itemize}
  	
  	\section{W modelu logicznym}
  	\begin{itemize}
  		\item są definicje indeksów
  		\item nie może być związków n..m
  		\item występują klucze obce
  		\item nie mogą wystąpić związki 1..1
  	\end{itemize}
  	
  	\section{SQL base na pozimie RL}
  	\begin{itemize}
  		\item blokada w trybie dzielonym wszystkich wierszy odczytanych w bieżącej transakcji \emph{RL nie posiada trwałego S-LOCKa - blokady w trybie dzielonym.}
  		\item blokada w trybie wyłącznym wierszy zmodyfikowanych (chyba też do końca transakcji) \emph{?? RL nie zakłada X-LOCKA - blokady w trybie wyłącznym.}
  		\item \textbf{blokada w trybie dzielonym tylko jednego (ostatnio odczytanego) wiersza do czasu odczytania kolejnych danych} \emph{RL polega na krótkim nałożeniu S-LOCKa na wiersz, odczytaniu danych i zdjęciu go zaraz po odczytcie.}
  		\item umożliwia odczyt danych niezależnie od blokad nałożonych w innych transakcjach \emph{?? RL jest zależne od S-LOCKa.}
  	\end{itemize}
  	
  	% pytanie 5    
  	\section{Kiedy serwer bazy danych zdejmuje blokady}
  	\begin{itemize}
  		\item \textbf{po COMMIT} \emph{generalnie trzeba zakończyć transakcję}
  		\item gdy wykonujemy następny CONNECT z aktualnie używanej aplikacji
  		\item w fazie prepare gdy następuje ona po instrukcjach DML
  		\item \textbf{po ROLLBACK} \emph{trzeba zakończyć transakcję}
  	\end{itemize}
  	
  	\section{SQL base na pozimie RL}
  	\begin{itemize}
  		\item blokada w trybie dzielonym wszystkich wierszy odczytanych w bieżącej transakcji
  		\item \textbf{blokada w trybie dzielonym zawsze tylko jednego (ostatnio odczytanego) wiersza do czasu odczytania kolejnych danych}
  	\end{itemize}
  	
  	\section{Co to jest ROWID: służy m.in.}
  	\begin{itemize}
  		\item do ułatwienia wyszukiwania rekordów
  		\item \textbf{do wykrywania zmian w rekordach} \emph{bo przy zmianie rekordu zastępuje zmiana ROWID, więc różne ROWID tego samego rekordu oznaczają zmianę w jego treści}
  		\item  do nadawania indeksów 
  		\item \textbf{czy jest w każdej tabeli.} \emph{jest w każdej tabeli i tyle}
  	\end{itemize}
  	
  	\section{Model logiczny - co występuje, a co nie}
  	\begin{itemize}
  		\item \textbf{relacje 1..1}
  		\item \textbf{relacje n..n}
  		\item indeksy
  		\item klucze obce
  	\end{itemize}
  	
  	\section{Kiedy system zdejmuje blokady}
  	\begin{itemize}
  		\item \textbf{commit} \emph{zakończenie transakcji}
  		\item \textbf{rollback} \emph{zakończenie transakcji}
  		\item faza prepare następnego zapytania
  		\item nowy connect na tym samym uchwycie
  	\end{itemize}
  	
  	% pytanie 10    
  	\section{W implementacji mechanizmu transakcyjnego w systemie DBMS SQLBase}
  	\begin{itemize}
  		\item \textbf{Zwolnienie wszelkich nałożonych blokad w bieżącej transakcji, następuje w sytuacji wykonania polecenia ROLLBACK w bieżącej transakcji}
  	\end{itemize}
  	
  	\section{W systemie transakcyjnym DBMS SQLBase}
  	\begin{itemize}
  		\item System podziału transakcji (mechanizm SAVEPOINT- ROLLBACK ) pozwala na wycofywanie i zatwierdzanie fragmentów transakcji
  	\end{itemize}
  	
  	\section{Kolumna ROWID w systemie zarządzania bazą danych SQLBase}
  	\begin{itemize}
  		\item \textbf{Jest kolumną dostępną w każdej tabeli}
  	\end{itemize}5
  	
  	\section{Określ prawdziwość zdań dotyczących realizacja fazy zapytania/zdania SQL w systemie zarządzania bazą danych SQLBase}
  	\begin{itemize}
  		\item \textbf{Faza Execute powoduje przesłanie wartości zmiennych wiążących – wartości parametrów komendy SQL}
  	\end{itemize}
  	
  	
  	%===============================================================================
  	%*** BUDOWA BAZY DANYCH ********************************************************
  	%===============================================================================
  	\part*{Budowa bazy danych}
  	\section*{Budowa fizyczna}
  	\begin{itemize}
  		\item Plik .dbs
  		\item Budowa bazy danych (dwukierunkowa lista stron)
  		\item Strony bazy danych (1K)\\
  		\textbf{Rodzaje stron}:
  		\begin{itemize}
  			\item data row pages (slots)
  			\item data extend pages (big columns)
  			\item data long varchar pages
  			\item data index pages (B+ trees)
  			\item data overflow pages (for cluster hashed tables)
  			\item data control pages (database control page, free extend list, group free page list, ...)
  		\end{itemize}
  	\end{itemize}
  	
  	%===============================================================================
  	%*** PODSTAWY ********************************************************
  	%===============================================================================
  	\section*{Podstawowe pojęcia}
  	\begin{itemize}
  		\item \textbf{Strona} - Data Row Page, rodzaj strony z wierszami bazy danych.
  		\item \textbf{Tablica} - dwukierunkowa lista stron.\\
  		\textit{Tablica na wielu stronach}.\\
  		
  		\item \textbf{Slot} - miejsce, gdzie może leżeć wiersz.
  		\begin{itemize}
  			\item Mogą to być różne pozycje, ponieważ długość wiersza nie jest zdefiniowana.
  			\item Jeżeli strona nie jest w pełni wypełniona, zostają puste miejsca.
  			\item Są numerowane, każdy posiada Update Number. Numer ten jest wyznaczany poprzez globalny licznik Insert Number. \emph{Nie jestem pewien}
  			\item Każdy posiada wskaźnik do extentu (osobny typ strony).
  		\end{itemize}
  		\item \textbf{Header} - zawiera informacje o slotach.
  		\item \textbf{Footer} - suma kontrolna (CRC, bit parzystości, klucz, szyfrowanie).
  	\end{itemize}
  	
  	% =======================================================================
  	% *** STRONY *****************************************************
  	% ========================================================================
  	\part*{Strony}
  	\section*{Co to jest?}
  	Strona to podstawowa wewnętrzna struktura bazy danych (jednostka przechowywania danych), która służy do organizacji informacji w bazie danych.
  	\section*{Rodzaje stron}
	  	\subsection*{Data Row Page}
	  	Rodzaj strony z wierszami bazy danych.\\
		Strony w pliku, strona ma numer - Page Number (PN) - 4B. Offset w pliku bazy danych.\\
		Na 4B można zaadresować 4GB, ale jeden bit wykorzystywany do czegoś innego więc 2GB. Przestrzeń ma maksymalny rozmiar.\\
		Przy dużej użytkowaniu bazy dochodzi do defragmentacji stron i przeładowania bazy.
  		\subsection*{Extent Page}
  		Strona przyrostowa przeznaczona dla "extentów". Jest zjawiskiem niepożądanym, którego istnienie wynika z fragmentacji. Po aktualizacji bazy danych mogą powstać extent pages jeżeli po defragmentacji ilość danych nie mieści się w jednym segmencie (stronie).
  		\subsection*{Long Page} 
  		Inna przestrzeń tabel z inną jednostką alokacji przeznaczoną dla obiektów typu BLOB.\\
  		BLOB - Binary Large OBject.\\
  		Long Page zakłada drugą przestrzeń tabel przeznaczoną dla obiektów dziwnych typów, jak np. BLOB, w celu uniknięcia mieszania typów (np. prostych i dziwnych).\\
  		W skrócie: jest wykorzystywane, gdy strona posiada wiele sekcji danych, które są podzielone na grupy.
  		\subsection*{Index Page}
  		B-Tree lub B+-Tree. Każdy węzeł drzewa indeksowego to jedna strona 1k. Jest to efektywniejszy sposób przechowywania danych.
  		\subsubsection*{Właściwości}
  		\begin{itemize}
  			\item Złożoność obliczeniowa jest w przybliżeniu równa \(log_M N\).
  			\item W celu rzadszego przebudowywania drzewa (zmiany, degradacji indeksu) istnieje też "\textbf{precent free}" (\textbf{PCTFREE}) - rezerwuje więcej wolnego miejsca na przyszłość, przeważnie 10 - 30\%.
  			\item Węzły B-drzewa połączone od lewej do prawej. Gdyby czytać wartości kluczy to będą one w porządku niemalejącym, w celu wprowadzenia uporządkowania.
  			\item Łatwość wyszukiwania informacji.
  		\end{itemize}
  		\subsubsection*{Cluster Hashed}
  		W celu polepszenia wydajności takich drzew indeksowych stosuje się nowy rodzaj indeksu, \emph{Cluster Hashed}, który jest oparty na funkcji hashującej. W zasadzie nie jest to indeks, a sposób umieszczania w pliku. Definiujemy go wzorem:\\\\
  		\centerline{\textit{create cluster hashed index NAME on PRAC(nrp) size N [buckets]}}
  		\subsubsection*{Cechy Cluster Hashed}
  		\begin{itemize}
  			\item Bucket (kubełek) - strona na wyjściu
  			\item N - ilość stron
  			\item Przy pominięciu Buckets, N oznacza liczbę rekordów, silnik sam szacuje rozmiar rekordu i stwierdzi ile rekordów przypada na 1 stronę.
  			\item Nie tworzy indeksu, tylko mówi jak te dane mają być umieszczane. Można założyć tylko jeden cluster hashed, ponieważ jest to sposób ułożenia danych.
  			\item Funkcja mieszająca na podstawie klucza zwracająca od razu nr strony. Kubłem jest strona.
  			\item Trzeba podać rozmiar, więc sprawdza się dla zbiorów o niezmiennym rozmiarze lub wolno rosnących.
  		\end{itemize}
  		\subsubsection*{Przykładowy generator multiplikatywno-addytywny}
  		\centerline{\(x_{n+1} = ((a\times x_{n}) + b) \mod n\)}
  		\textbf{Własciwosci}:
  		\begin{itemize}
  			\item a, b oraz n powinny być liczbami pierwszymi.
  			\item Prosty generator losowy, ale z wadami. Skoro zwraca numer strony, fajnie by było aby były dość blisko (odczytywanie).
  			\item Numer strony jest dzielony mod P (P - liczba pierwsza większa od N?) aby były umieszczone.
  			\item Wady: służy tylko do zapytań X = WARTOSC. Przy kolizjach tworzy się dodatkowa strona.
  			\item Zalety: dostajemy to co chcemy w jednym kroku.
  		\end{itemize}
  	
  		\subsection*{Overflow Page}
  		Tworzona gdy przepełni się strona \textit{Cluster Hashed}, strona z danymi albo przy kolizji
  		
  	% ========================================================================
  	% *** kolumny ROWID *****************************************************
  	% ========================================================================
  	\part*{Kolumny ROWID}
  	\section*{Co to jest?}
  	Tworzone przy rodzaju stron Data Row Page. Unikalna identyfikacja każdego wiersza, wartości w kolumnie ROWID jednoznacznie identyfikują wiersz w tablicy.
  	% --- Własciwosci
  	\section*{Właściwości}
  	\begin{itemize}
  		\item Każda tablica posiada domyślnie kolumnę ROWID (obsługiwaną przez serwer bazy danych), którą można odczytywać w ramach wykonywania komend SELECT, UPDATE, DELETE
  		\item Po zmianie jakiejkolwiek wartości w wierszu następuje zmiana wartości ROWID (z zachowaniem unikalności w ramach tablicy) – umożliwienie wersjonowania (versioning). 
  		\item Budowa ROWID: identyfikator powstaje na skutek sklejenia odpowiednich wartości: page number, slot number, row serial number (insert sn), update serial number
  		\begin{center}
  			\(ROWID = PageNumber  + InsertNumber + SlotNumber + UpdateNumber\)
  		\end{center}
  		\item Mimo to jest typu STRING i można go używać w zdaniach SQL tak jak nazwy kolumny
  		\item Zmienia wartość po każdej zmianie wiersza - należy korzystać z nich ostrożnie, zwłaszcza w formularzach \emph{master-detail}
  	\end{itemize}
  	\section*{Wykorzystanie}
  	\begin{itemize}
  		\item Służy do identyfikacji wiersza
  		\item Ponieważ ROWID jednoznacznie identyfikuje wiersz, wykorzystuje się go przy tworzeniu wynikowej tablicy dla zapytań (Result Set)\\
  		Przykład:\\
  		\emph{SELECT} atr1, atr2, atr3\\
  		\emph{FROM} tab\\
  		\emph{WHERE} 'cond'\\\\
  		\textbf{Wynik:}\\
  		\begin{tabular}{|r|l|}
  			\hline 
  			ROWID${_1}$\\
  			\hline
  			ROWID${_2}$ \\
  			\hline
  			...\\
  			\hline
  			ROWID${_n}$\\
  			\hline
  		\end{tabular}
  		\item W wypadku, kiedy zapytanie wymaga złączenia kilku tablic
  		\item Do koordynacji działania dwóch kursorów
  	\end{itemize}
  		
  	%===============================================================================
  	% *** ZABEZPIECZENIE BAZY DANYCH ***********************************************
  	%===============================================================================
  	\part*{Zabezpieczenie bazy danych}
  	
  	\section*{Logi}
  	\subsection*{Co to jest?}
  	Pliki z obrazami transakcji (przed i po jej wykonaniu), albo zbiory z opisami transakcji.
  	\subsection*{Przykład logu}
  	\begin{itemize}
  		\item Transakcja 108 start  + data i czas
  		\item Stara wartość
  		\item Nowa wartość
  		\item Transakcja 108 stop + data i czas
  	\end{itemize}
  	\subsection*{Zarządzanie logami}
  	Kolejno tworzone są pliki: 1.log, 2.log itd. Pliki .log się wymieniają -$ > $ po utworzeniu 2.log, 1.log nie jest już potrzebne.
  	\subsection*{Położenie logów}
  	Można plik bazy danych i log umieścić na osobnych dyskach - dane na STRIPE, log na MIRROR. Oba procesy nazywa się odpowiednio stripping oraz mirroringiem. Na STRIPE zapis jest buforowany, a na MIRROR niebuforowany (szybki, bezpieczny, ale zajmuje mało miejsca).
  	
  	\section*{Komenda ROLLBACK (UNDO)}
  	\begin{itemize}
  		\item \emph{Before Image} - to co się stało i nie jest zatwierdzone (bez commit)
  		\item \emph{After Image} - to co się stało i jest zatwierdzone (po commit)
  		\item Nie powinno być długich transakcji. Do odtworzenia z logu też potrzebne jest miejsce oraz też jest to operacja transakcyjna.
  		\item Przy odtwarzaniu logów potrzebuje on drugie tyle logów do odtworzenia.
  		\item \emph{TSL} (Transaction Span Limit) – parametr ochronny, zostawia tyle wolnego miejsca ile zajmują logi dotychczasowe, żeby nie zabrakło miejsca i żeby nie tworzyć zbyt długich transakcji.
  		\item Komenda \textit{set log backup} - aby zrealizowane transakcje (after images) nie były kasowane.
  	\end{itemize}
  	
  	\section*{Komenda ROLLFORWARD (REDO)}
  	Zrób jeszcze raz. Można restorenąć backup bazy danych.
  	\subsection*{Możliwości}
  	\begin{itemize}
  		\item ROLLFORWAD TO END - ponowne wykonanie transakcji -$ > $ uzupełniona po ostatnią transakcję, która się skończyła (posiada znacznik końca).
  		\item ROLLFORWAD TO "DATETIME" - wszystkie transakcje której zakończyły się do pewnej godziny. Umożliwia zoptymalizowania backupowania, np. od poniedziałku do czwartku wykonywane są backupy logów (BACKUP LOG), a w piątki bazy danych (BACKUP DATA BASE). Muszą być wtedy backupy ze wszystkich dni, by przypadkiem któregoś nie zgubić.
  		\item ROLLFORWAD END - zakończenie rollforwardowania
  		\item ROLLFORWAD CONTINUE - po skończeniu kontynuacja rollforwardowania
  	\end{itemize}
  	
  	\section*{Cache bazy danych}
  	Dane nie są zapisywane od razu z powrotem/ Szuka w tym cache'u, a nie w bazie (??).
  	\subsection*{Dirty page}
  	W cache ma inną wartość niż w bazie danych. Ale zapisane w logu.
  	\subsection*{Checkpoints}
  	Mechanizm zdarzeń. Tworzone są rzadko, np. co 20 minut, gdy jest przepełnienie cache, w idle time.
  	Gdy nadejcie CHECKPOINT wtedy zawartość cache jest zrzucana i nie ma już brudnych stron.
  	
  	\section*{Przykładowy scenariusz}
  	\begin{tabular}{|l|l|}
  		\hline
  		1.log: & 2.log\\
  		\(110+dt\) & ... //110\\
  		... & ...\\
  		\(109+dt\) & \(111+dt\)\\
  		... & ...\\
  		\(108+dt\) & \(111-dt\)\\
  		... & ...\\
  		\(108-dt\) & \(112+dt\)\\
  		... & ...\\
  		CHECKPOINT & \\
  		... & \\
  		\(109-dt\) & \\
  		... & \\
  		\hline
  	\end{tabular}\\
  	\subsection*{Co się dzieje?}
  	\begin{itemize}
  		\item 112 - rozpoczęta, ale nie zakończona - ignorowana.
  		\item 111 - zakończyła się, więc REDO, trzeba pchnąć do cache
  		\item 109 - to co się stało do checkpointa zostało zapisane, ale skończyła się po checkpoincie. Ten kawałek po checkpoincie trzeba pchnąć REDO
  		\item 110 - nie skończyła się przed rozpoczęciem - trzeba ją wycofać, UNDO
  		\item 108 - można zignorować, bo się skończyła po checkpoincie
  	\end{itemize}
  	\subsection*{Gdy się zapełni cache - mechanizm}
  	\begin{itemize}
  		\item LRU - Last Recently Used - wywalać te, które były najpóźniej użyte.
  		\item LFU - Last Frequently Used - wywalić ten, który najrzadziej był używany.
  		\item LFRU - kombinacje (np. liniowe)
  		\item Cache (do optymalizacji SELECTION), różne typy, różne mechanizmy dla różnych cache
  		\begin{itemize}
  			\item Recycled - rzeczy związane z danymi operacyjnymi, często się zmieniające
  			\item Permanent - słowniki kodów terytorialnych, kodów miast itp.
  		\end{itemize}
 	\end{itemize}
 	
  	\section*{Praca bez transakcji}
  	Nietypowy tryb, co najwyżej do serwisu, w wyjątkowych okolicznościach, raczej niesotsowany obecnie.\\
  	Komenda \emph{set recovery off} - tryb single user, powoduje odcięcie się od wszystkich.
  	
  	% ======================================================================
  	% === BACKUPOWANIE BAZ DANYCH
  	% ======================================================================
  	\part*{Backupowanie baz danych}
  	\section*{Backup online} \noindent 
  	BACKUP {DATABASE, LOGS, SNAPSHOT} FROM \(<db>\) TO $ < $dir$ > $ ON {CLIENT, SERVER}\\
  	Może tworzyć, przenosić itd.
  	Komenda SETLOGBACKUP ON sprawia, że nie kasuje logów.
  	\begin{itemize}
  		\item BACKUP DATABASE - baza i logi
  		\item BACKUP LOGS - tylko logi
  		\item BACKUP SNAPSHOT - backup bazy i logów tworzony gdy inni pracują. Stan bazy danych w chwili naciśnięcia, bez konieczności (...) innych użytkowników.
	  	\begin{enumerate}
	  		\item \textbf{BACKUP SNAPSHOT}\\
	  		Można go robić gdy inni pracują. Robi backup chwilowy. W czasie backupu to co jest wykonywane na bieżąco jest w innym pliku składowane, a po backupie łączone.
	  		\item \textbf{Incremental backup}\\
	  		SET LOGBACKUP ON\\
	  		BACKUP DATABASE\\
	  		BACKUP LOGS
	  	\end{enumerate}
  	\end{itemize}
  	\section*{Offline backups} \noindent 
  	COPY ... (copy on server)\\
  	SET NEXT LOG $ < $n$ > $\\
  	\section*{Odtwarzanie} \noindent 
  	RESTORE (DATABASE, LOGS, SNAPSHOT) FROM $ < $db$ > $  ON {CLIENT, SERVER} TO $ < $dir$ > $\\
  	Odtwrza odpowiedni BACKUP ...\\
  	ROLLFORWARD $ < $db$ > $ TO {END, BACKUP, TIME $ < $dt$ > $}\\
  	ROLLFORWARD $ < $db$ > $ TO END\\
  	ROLLFORWARD $ < $db$ > $ TO CONTINUE
  	\section*{Wywoływanie | ładowanie bazy danych} \noindent 
  	UNLOAD DATABASE $ < $file$ > $\\
  	UNLOAD COMPRESS DATABASE $ < $file$ > $ ON SERVER LOG $ < $logfile$ > $ (log - napisane gdzie się wywrócił)\\
  	UNLOAD SQL $ < $file$ > $ $ < $table$ > $\\
  	UNLOAD SCHEMA $ < $file$ > $\\\\
  	(tryb recovery off, tryb autocommiton)\\
  	LOAD SQL $ < $file$ > $\\
  	LOAD COMPRESS SQL $ < $file$ > $ ON SERVER LOG $ < $logfile$ > $\\
  	LOAD ASCII $ < $file$ > $ $ < $table$ > $\\
  	SET BULK ON; - dodatkowy tryb w wielu serwerach. Dotyczy tego jak wygląda komunikacja między klientem a serwerem. Inna organizacja cache, grupowanie ich, np. wiele insertów - przekazuje do bufora np. 20 insertów jednocześnie zamiast każdego osobno.\\
  	LOCK DATABASE
  	
  	
  	% ======================================================================
  	% === Tablice systemowe
  	% ======================================================================
  	\part*{Tablice systemowe}
  	\section*{O co chodzi?}
  	\textbf{Metaschemat} - słownik bazy danych, samoopisująca się baza danych
  	\section*{Tablice, kolumny, perspektywy}
  	\begin{itemize}
  		\item \textbf{SYSTABLES} - rowCount, pageCount, pageNumber - w miarę aktualne, ale raczej aktualizowane na żądanie
  		\item \textbf{SYSCOLUMNS} - też dane statystyczne + średnia długość pola
  		\item \textbf{SYSVIEWS}
  	\end{itemize}
  	\section*{Indeksy}
  	\begin{itemize}
  		\item \textbf{SYSINDEXES} - twórca, nazwa, tablica, unikalność, l. kolumn klucza, typ indeksu B+/ClusterHashed\\
  		B+ : Wysokość drzewa, leaf count - liczba liści\\
  		CH:  Primary Pages (w 1 uderzeniu, liczba stron właściwych); Overflow pages (liczba stron dodatkowych)
  		\item \textbf{SYSKEYS} - Składowe klucze indeksów, statystyki
  	\end{itemize}
  	\section*{Poziomy bezpieczeństwa}
  	\begin{itemize}
  		\item \textbf{SYSADM} : singleton, może tworzyć userów
  		\item \textbf{DBA} : mogą robić wszystko poza operacjami na użytkownikach (ich tworzenie i klasyfikacja)
  		\item \textbf{RESOURCE} : może tworzyć własne obiekty, ma prawo do swoich obiektów
  		\item \textbf{CONNECT} : może się połączyć, ale w wielu systemach baz danych nie może nic ponadto dopóki ktoś inny mu nie nada praw
  	\end{itemize}
  	\section*{Uprawnienia}
  	\begin{itemize}
  		\item \textbf{SYSUSERAUTH} - użytkownicy na poziomie bazy danych, typ użytkownika (patrz wyżej)
  		\item \textbf{SYSABAUTH} - prawa użytkownika do wykonywanie operacji na tablicach i perspektywach (Select, Import, Update, U cols, Delete, Alter, INDeks)
  		\item \textbf{SYSCOLAUTH} - prawa użytkownika do update poszczególnych kolumn tablic (column update privileges), podrzędny do SYSABAUTH
  		\item \textbf{SYSSYNONYMS} - synonimy tablic, perspektyw, procedur bazy danych. Dzielimy je na:
  		\begin{itemize}
  			\item publiczne, jak np. SYSADM.pracownik
  			\item niepubliczne, jak np. Rafał.pracownik as SYSADM.superpracownik, stosowane w celu bezpieczeństwa
  		\end{itemize} i niepubliczne
  		\item \textbf{SYSEXECUTEAUTH} - prawo do wykonywania procedur baz danych
  		\begin{itemize}
  			\item Z przywilejami twórcy (with creator privileges) - można zostać na chwilę rootem, np. SYSADM tworzy procedurę dla userów DBA
  			\item Z przywilejami wykonawcy (with grantee privileges)
  		\end{itemize}
  	\end{itemize}
  	\section*{Więzy integralności}
  	\begin{itemize}
  		\item \textbf{SYSPKCONSTRAINTS} - definicja klucza pierwotnego
  		\item \textbf{SYSFKCONSTRAINTS} - definicja klucza obcego
  		\item \textbf{SYSTABCONSTRAINTS} - zachowanie w układzie master-detail tables (ON DELETE: RESTRICT/CASCADE/SET NULL)
  	\end{itemize}
 	\section*{Inne}
  	API klient-serwer: CONNECT -$ > $ PREPARE -$ > $ EXECUTE -$ > $ FETCH -$ > $ DISCONNECT
  	\begin{itemize}
	  	\item \textbf{SYSCOMMANDS} - nazwa, uchwyt, treść, znaczniki, procedury
	  	\begin{itemize}
	  		\item stored command, już skompilowana komenda (raz wykonany plan zapytania). Wada: plan jednorazowy, a przecież stan bazy danych się zmienia, brak automatyzacji.
	  		\item procedury: static (prekompilowane, szybkie, ale z powyższą wadą), dynamic (tylko kod)
	  	\end{itemize}
	  	\item \textbf{SYSEXTFUN} - external functions. Umożliwia napisanie DLLki np. w C i dodawanie potem procedur
	  	\item \textbf{SYSTRIGGERS}
	  	\item \textbf{SYSEVENTS} - serwer czasu (~ scheduler, cron), umożliwia wykonywania pewnych czynności o określonych porach, np. wyładowanie/załadowanie bazy danych, odświeżania statystyk, czynności maintenance
  	\end{itemize}
  	
  	% ======================================================================
  	% === REALIZACJA ZAPYTAŃ PO STRONIE SERWERA
  	% ======================================================================
  	\part*{Realizacja zapytań po stronie serwera}
  	W dzisiejszych czasach wykorzystuje się ODBC, ADO.NET.
  	\section*{Fazy wykonywania SQL API}
  	\begin{itemize}
  		\item sql connect (con)
  		\item sql prepare (prep)
  		\item sql execute (exe)
  		\item sql fetch
  		\item sql commit
  		\item sql disconnect
  	\end{itemize}
  	
  	\subsection*{sqlConnect} \noindent 
  	Baza, user, pass\\
  	Returns kursor.\\
  	Można działać na kilku kursorach, ale w obrębie tej samej transakcji. \emph{nie jestem pewien}
  	\subsection*{sqlPrepare} \noindent 
  	Zapytanie + parametry (bind\_var - np. war selekcji; into\_var - do pobierania)\\
  	Zmienne z ":"\\
  	Przesłanie komendy, analiza syntaktyczna i semantyczna, sprawdzenie uprawnień, podstawienia, optymalizacja
  	\subsection*{sqlExecute} \noindent 
  	Wysłanie zmiennych wiązanych (bind\_var), wykonanie komendy (result set)\\
  	Blokady przy modyfikacji
  	\subsection*{sqlFetchNext} \noindent 
  	Pobranie wiersza, (zmienne into\_var)
  	\subsection*{sqlDisconnect} \noindent 
  	Odłączenie kursora
  	\subsection*{sqlCommit} \noindent 
  	Dla modyfikacji. Kilka kursorów, w jednej puli, commit commituje na wszystkich kursorach w puli.
  	\subsection*{sqlPrepareAndExecute} \noindent 
  	2 w 1
  	\subsection*{sqlImmediate} \noindent 
  	Sama komenda, nie ma kursora (sqlHandle), wszystko razem (connect, prepare, execute, fetch - sam sobie zarządza).\\ Wykonuje się na ostatnio użytym kursorze (ten sam user, hasło, baza danych)
  	
  	
  	% ======================================================================
  	% *** OPTYMALIZACJA *************************
  	% ======================================================================
  	\part*{Optymalizacja}
  	\section*{PREPARE}
  	3 sposoby szacowania sposobów zapytania
  	\begin{itemize}
  		\item \textbf{Selektywność zapytań} (selectivity factor) - parametr, który szacuje wynik zapytania, czyli jaki procent wierszy spełnia warunki zapytania, wartość $ < $0, 1$ > $ - prawdopodobieństwo, że losowo wyciągnięty wiersz z tablicy spełnia warunki zapytania.\\
  		Statystyki, do szacowania zapytań.\
  		\begin{itemize}
  			\item \textbf{Histogramy} (nieparametryczny estymator funkcji gęstości)
  			\begin{itemize}
  				\item O niskiej rozdzielczości i stałej szerokości
  				\item Problem rozdzielczości i aktualności histogramu (UPDATE STATISTICS)
  				\item Przykład:\\
	  				\begin{tabular}{c|c|c|c|c|c}
	  					\hline
	  					0-10 & 10-20 & 20-30 & 30-40 & 40-50 & 50-60\\
	  					\hline
	  					\(\frac{1}{7}\) & \(\frac{1}{7}\) & \(\frac{2}{7}\) & \(\frac{2}{7}\) & \(\frac{1}{7}\) & \(\frac{1}{7}\)\\
	  					\hline
	  				\end{tabular}\\\\
	  				\(sel(20 < x < 30)=\frac{2}{7}\)\\
	  				\(sel(20 < x < 40)=\frac{4}{7}\)\\
	  				\(sel(15 < x < 30)=\frac{1}{2}\times \frac{1}{7}+\frac{2}{7}\)\\ - zakładamy, że rozkład w 10 $ < $ x $ < $ 20 jest stały.
  			\end{itemize}
  			\item \textbf{Kardynalność} (\textit{cardinality}) - liczba unikalnych wartości kolumny w tablicy\\
  			\textbf{selectivity factor} = \(\frac{1}{Cardinality}\) - dokładne dla unikalnych kolumn\\\\
  			\(Card(x)<->sel(x='val')=\frac{1}{Card(x)}\)
  			\item \textbf{Trzeci sposób} - płytkie wejście w drzewo indeksowe (\textit{b-tree scan})
  			\begin{itemize}
  				\item Gdy trafi granica w klucz to ok. Niejako spełnia rolę histogramu
  				\item Założenie że node równomiernie dzieli dziedzinę
  				\item Metoda najmniej dokładna i najmniej kosztowna
  				\item Przy złożonym warunkiem zapytania: mnożenie (założenie o niezależności wartości atrybutów, reguła AVI)
  			\end{itemize}
  			\textbf{Przykład - do uzupełnienia.}
		\end{itemize}
  	\end{itemize}
  	
  	\section*{Optymalizacja zapytań} \noindent 
  	\subsection*{select nazwisko from pracownik where nrp in (6,7,8)} 
  	Istnieje pracownik o nrp = 6\\
  	%\includegraphics[width=10cm]{be}\\
  	\textbf{Gdzie}:
  	\begin{itemize}
  		\item Liść to strona, która zawiera wiersze
  		\item Idea działania jest taka sama jak drzewa wyważonego
  	\end{itemize}
  	\subsubsection*{Jak serwer realizowałby zapytanie?}
  	\begin{enumerate}
  		\item \textbf{Założenia}
  		\begin{itemize}
  			\item Page Count, \(PC = 1000\)
  			\item Row Count, \(RC = 10000\) - przybliżona liczba wierszy
  			\item \(\frac{RC}{PC} ~= 10\)
  			\item H - wysokość drzewa
  			\item L - leaf count, liczba liści
  		\end{itemize}
  		\item \textbf{Metoda}
  		\begin{itemize}
  			\item Oszacowanie kosztu dla nrp = 6\\
  			\((H - 1) + 1\)\\
  			Minus jeden wynika stąd, że korzeń jest już w pamięci.
  			\item 	Oszacowanie kosztu dla nrp in (6, 7, 8)\\\\
  			\(sel(nrp = 6) = \frac{1}{10000}\) (cardinality)\\\\
  			\(sel(nrp in (6,7,8)) = \frac{3}{10000}\) (cardinality)\\\\
  			\(sel\times{RC}=\frac{3}{10000}\times{10000}=3\)\\\\
  			Przejście 3 razy: \(((H-1)+1)\times{sel\times{RC}}\) - koszt
  		\end{itemize}
  		\item \textbf{Przykład}\\
  		H = 4\\
  		Koszt: \(3\times((4-1)+1) = 12\) - liczba stron potrzebna do ściągnięcia.
  		\item \textbf{Porównanie}
  		\(12 < 1000 (PC)\)\\
  		Lepiej w oparciu o indeks niż przeglądać strony.
  	\end{enumerate}
  	
  	
  	\subsection*{select nazwisko from pracownik where nrp \(>=\) 6} \noindent 
  	Przeszukiwanie liści, ale nie \(L\), a \(sel\times L\) liści zostanie przejrzane. Najpierw skacze do 6, a potem w prawo. Korzysta z listy liści.\\\\
  	Dla \(6 <= nrp < 14\) przechodzi tylko tyle liści, żeby warunek był spełniony.\\
  	Dla małego sel nadal się opłaca:\\
  	\(koszt = (H-1)+sel\times L + sel \times RC\) - wyskakiwanie po wiersze. $  sel \times RC\ $ - liczba wyjść do stron.
  	
  	\subsection*{select nazwisko from pracownik order by nrp} \noindent 
  	\(sel = 1\)\\
  	Koszt: \((H-1)+L+RC\)
  	
  	\subsection*{select nazwisko from pracownik order by nrp where 6 $ <= $ nrp $ < $ 14} \noindent 
  	Tak samo jak \textbf{select nazwisko from pracownik where nrp $ >= $ 6}, ponieważ są już uporządkowane.
  	
  	\subsection*{select nrp from pracownik where  6 $ <= $ nrp $ < $ 14 order by nrp}
  	Najszybszy i najefektywniejszy rodzaj zapytania.\\
  	Zapytanie \textbf{INDEX ONLY} - nie trzeba sięgać do tablic, bo wszystko siedzi w liściach drzewa.\\
  	Koszt: \((H-1)+sel\times L\)\\ - zejście w dół + przejście po liściach.\\
  	Nie należy go nadużywać, mogą wyniknąć problemy gdy indeks jest mało wykorzystywany, a wprowadza się dużo nowych danych.
  	
  	\subsection*{Indeks typu CLUTER HASHED}
  	Strony typu \textit{primary pages} przy tworzeniu indeksu (w praktyce trochę większe, aby było lepiej) oraz Overflow pages.\\
  	\begin{table}[h]
  		\begin{tabular}{|c|lcll}
  			\cline{1-1}
  			\multicolumn{1}{|l|}{Primary pages (P)} &                                    & \multicolumn{1}{l}{Overflow pages (O)} &  &  \\ \cline{1-1} \cline{3-3}
  			...                                     & \multicolumn{1}{l|}{-\textgreater} & \multicolumn{1}{c|}{...}               &  &  \\ \cline{1-1} \cline{3-3}
  			...                                     &                                    &                                        &  &  \\ \cline{1-1} \cline{3-3}
  			...                                     & \multicolumn{1}{l|}{-\textgreater} & \multicolumn{1}{c|}{...}               &  &  \\ \cline{1-1} \cline{3-3}
  		\end{tabular}
  	\end{table}
  	Koszt $ = sel\times RC\times 1 = 1 $ przy nrp = 6.\\
  	nrp in (6,7,8) - koszt $ = sel\times RC\times 1 = 3 $ - pesymistyczny przypadek, bo wszystkie mogą być na osobnych stronach.\\
  	Ale to gdy nie trafi na overflow page.\\
  	Stosunek: $ \frac{P+O}{P} $ - stosunek wszystkich stron przez primary pages. Początkowo równy jeden, gdy $ O = 0 $.\\
  	Selektywność (koszt) zapytania: $ sel\times RC\times \frac{P+O}{P} $.\\
  	Najpierw wyliczana selektywność, a potem koszt różnych sposobów.
  	
  	% ============================================================================
  	% === SPOSOBY ŁĄCZENIA TABLIC
  	% ============================================================================
  	\section*{Sposoby łączenia tablic (nazwy)}
  	\begin{itemize}
  		\item \textbf{NESTED LOOP}\\
  		najgorsza z możliwych metod. Fatalna złożoność obliczeniowa rzędu $ m \times n $\\
  		\(m=1000\)\\\(n=1000\)\\\(n\times{m}=1000000\)
  		\item \textbf{INDEX LOOP}\\
  		Szukanie z indeksem. Łączymy, ale po tym co łączymy mamy indeks. Koszt: 
  		\(m\times({h}+1)=m\times{(\log_d n+1)}\) - plus jeden, bo skok po wiersz.\\
  		Dla d = 10 \(O=1000\times{(3+1)}=4000\). Gdzie:
  		\begin{itemize}
  			\item d - liczba wyprowadzeń z węzła
  			\item H - wysokość drzewa
  			\item n - liczba węzłów
  			\item $ H=\log_d n $
  		\end{itemize}
  		Złożoność rzędu \((m\times\log{n})\)
  		\item \textbf{SORT\_MERGE} (uporządkuj i scal)\\
  		W przypadku pesymistycznym, dla dużych n i m, a nie można wykorzystać wielu indeksów.\\
  		Złożoność \(m+n+m\log_2 m+n\log_2 n\)\\
  		Gdzie:\\
  		\(n+m\) - przejście raz po każdej tablicy (scalanie)\\
  		\(m\log_2 m+n\log_2 n\) - sortowanie tablic\\
  		Np. $ 1000 + 1000 + 1000\times10 + 1000\times10 = 22 000 $
  		\item \textbf{HASH JOIN}\\
  		Z indeksem Cluster Hashed\\
  		Koszt: $ M\times1 $ (albo trochę więcej niż 1, jak 1,7).\\
  		Niech częściowe wyniki złączeń są w hash join za kolejne łączenie.\\
  		Można tablice tymczasowe (wyniki złączeń) jako cluster hashed i wtedy jest dobra do wykorzystania.
  	\end{itemize}
  	
  	% ============================================================================
  	% === AKTUALIZACJE TABLIC
  	% ============================================================================
  	\section*{Aktualizacje tablic w języku SQL} \noindent
  	UPDATE STATISTICS ON DATABASE
  	\begin{itemize}
  		\item ON TABLE $ < $tabname$ > $
  		\item ON INDEKX $ < $indeks$ > $
  	\end{itemize}
  	Aktualizuje parametry (-county), ale i też dane dla selektywności (histogram).\\
  	\textbf{Inne możliwości}:
  	\begin{itemize}
  		\item ANALYZE TABLE ESTIMATE ... STATISTICS - np. 10\% - z 10-procentowej próbki.
  	\end{itemize}
  	
	% ============================================================================
	% === MECHANIZMY SERWERA BAZY DANYCH
	% ============================================================================
	\section*{Transakcyjne przetwarzanie} \noindent
	Transakcje zaczynają się przy nadaniu poziomu izolacji (wyższych poziomów izolacji), ale można mówić, w uproszczeniu, że automatycznie przy instrukcji modyfikacji (INSERT, UPDATE, DELETE).
	\begin{itemize}
		\item SAVE POINT $ < $nazwa$ > $ - takie podzielenie transakcji, chociażby na checkpointy (stany bazy danych), by można było się wycofać do tego savepointa.
		\item ROLLBACK $ < $nazwa$ > $ - rollback do wskazanego savepointa.
		\item Savepointy żyją tak długo jak żyje transakcja.
	\end{itemize}
  	
  	% ======================================================================
  	% === POZIOMY IZOLACJI
  	% ======================================================================
  	\part*{Poziomy izolacji oraz blokady}
  	
  	\section*{Co to jest?}
  	Mechanizm, który umożliwia wielodostęp poprzez zastosowanie izolacji oraz blokad.
  	
  	% --- właściwości izolacji
  	\section*{Właściwości}
  	\begin{itemize}
  		\item Ustawienie poziomu izolacji decyduje o sposobie izolowania i blokowania danych 
  		\item Dla aplikacji istotnie wielodostępnych poziomy izolacji muszą być dobrane do okoliczności 
  		\item Blokowanie zapisu następuje na poziomie stron 
  		\item Blokady są zwalniane po COMMIT / ROLLBACK 
  		\item Poziomy izolacji ustala się:
  		\begin{itemize}
  			\item Poleceniem \emph{SET ISOLATION} 'poziom' w SQLTalk 
  			\item Funkcją \emph{SqlSetIsolationLevel} w SQLWindows
  		\end{itemize}
  		\item Każdy kursor otwarty przez klienta ma własny bufor wejściowy
  	\end{itemize}
  	
  	% --- blokady
  	\section*{Blokady}				
  	\begin{itemize}
  		\item \textbf{S-LOCK} - blokada w trybie dzielonym (shared), współdzielenie odczytu – każda transakcja może zablokować wybrany wiersz (rekord) i go odczytywać, Jeżeli chce go zmodyfikować, musi podnieść poziom blokady na X-LOCK, ale wtedy musi poczekać, aż inne transakcje zdejmą swoje S-LOCKi.
  		\item \textbf{X-LOCK} - blokada w trybie wyłącznym, przejęcie wiersza (rekordu) na własność – można czytać, modyfikować, ale inne transakcje nie mają dostępu do tych danych. Innymi słowy, służy do zapisu.
  		\item \textbf{U-LOCK} - Update (upgrade) lock. Może być tylko jeden na strone (podobnie jak X-LOCK). Transakcja (A) przejmuje dane na wyłączność, ale inne transakcje (B, C, D) mogą zakładać na nie S-LOCKi i odczytywać. \\ Jeśli A chce modyfikować dane, musi podnieść poziom blokady na X-LOCK, ale musi poczekać na zdjęcie przez pozostałe (B, C, D) blokad S-LOCK. U-LOCK daje A tą przewagę, że ona jako pierwsza będzie modyfikować dane, bo nikt inny nie założy X-LOCKa – bo U-LOCK blokuje strone. \\ Rzadko stosowany, posiada cechy obu poprzednich blokad.
  	\end{itemize}
  	
  	% --- poziomy izolacji
  	\section*{Poziomy izolacji}
  	\begin{itemize}
  		\item \textbf{DR} (\emph{Dirty Read}) - można czytać zawsze i nie wiadomo co się czyta (np. widzi dane niezatwierdzone commitem).
  		\item \textbf{RO} (\emph{Read Only})
  		\begin{itemize}
  			\item Nie ma S-LOCKa.
  			\item Tworzy się “select snapshot” - obraz całej bazy danych z momentu połączenia.
  			\item Odczytuje się dane spójne w danej chwil.
  			\item Innymi słowy - nie zakłada żadnych blokad, ale nie pozwala na modyfikacje.
  			\item Poziom przeznaczony do odczytów, które muszą zawierać dane z tej samej chwili.
  			\item Rzadko wykorzystywany.
  			\item Wada: wolne i nie można zrobić nic poza selectami.
  			\item Możliwość użycia tego trybu trzeba odblokować przez \emph{SET READONLY ON}
  			\item Przekazuje „migawkę" danych z chwili zadania zapytania.
  			\item Używa specjalnych plików .HIS do przechowywania migawki.
  		\end{itemize}
  		\item \textbf{RL} (\emph{Release Lock})
  		\begin{itemize}
  			\item Przeznaczony do odczytu
  			\item Nie ma S-LOCKa, ale w praktyce DBMS zakłada go na chwilę, upewnia się, że nie ma X-LOCKa, odczytuje dane, a następnie zwalnia S-LOCK - gwarancja spójności danych.
  			\item Schemat działania:
  			\begin{itemize}
  				\item Wypełnia bufor wejściowy danymi.
  				\item Zakłada blokadę na stronę na której jest kursor.
  				\item Zwalnia blokadę natychmiast po zakończeniu operacji.
  			\end{itemize}
  			\item Zapewnia dobry wielodostęp.
  			\item Nie można przeczytać czegoś co w danej chwili jest zmieniane.
  			\item Poziom przeznaczony do pokazywania wielu wierszy.
  		\end{itemize}
  		\item \textbf{CS} (\emph{Cursor Stability})
  		\begin{itemize}
  			\item Pobiera do bufora tylko pojedynczy wiersz.
  			\item Blokowana jest tylko „bieżąca" strona - ta na której jest kursor (S-LOCK).
  			\item Blokada jest zdejmowana gdy kursor przejdzie na inną stronę.
  			\item Dane między kolejnymi odczytami mogą być zmienione przez innych użytkowników - ryzyko wzajemnej blokady.
  			\item Generuje duży ruch na sieci, ale nie blokuje dostępu innym.
  			\item Poziom przeznaczony do zmian pojedynczych wierszy.
  			\item Wykorzystywane przy wybieraniu wierszy do modyfikacji ( użytkownik je sobie przegląda w aplikacji i wprowadza zmiany, a później zapisuje ). S-LOCK, U-LOCK, X-LOCK.
  			\item Składnia\\
  			\centerline{\emph{SELECT ... FOR UPDATE dla UPDATE .... WHERE CURRENT OF CURSOR}} - pobranie z zamiarem zmiany, nałożenie U-LOCKa.
  			\item Kursory mają timeouty.
  			\item Niektóre serwery robią graf transakcji - wywalana transakcja która zamknęła graf albo ta o najmniejszym koszcie.
  		\end{itemize}
  		\item \textbf{RR} (\emph{Repetable Read})
  		\begin{itemize}
  			\item Po to aby to co przeczytaliśmy nie zostało już zmienione w transakcji.
  			\item S-LOCK utrzymywany na wierszach już dotkniętych. COMMIT lub ROLLBACK ściągają blokady.
  			\item Nie chroni insertami (phantom row).
  			\item Działanie:
  			\begin{itemize}
  				\item Wypełnia bufor wejściowy danymi.
  				\item Wszystkie przeczytane strony zostają zablokowane.
  				\item Gwarantuje powtarzalność odczytów wiersza w ramach transakcji.
  			\end{itemize}
  			\item Jest to domyślny poziom izolacji.
  			\item Pełne blokowanie S-LOCK, U-LOCK, X-LOCK.
  			\item Składnia: {\emph{SET ISOLATION RL}}
  		\end{itemize}
  		\item \textbf{SE} (\emph{Serializable})
  		\begin{itemize}
  			\item Raz przeczytane to już nic się nie da zrobić, nawet dopisać.
  			\item Chroni przed INSERTami.
  			\item Zakłada blokadę na unikalny indeks z kluczem.
  		\end{itemize}
  	\end{itemize}
  	
  	
  	% ======================================================================
  	% === WIĘZY INTEGRALNOSCI
  	% ======================================================================
  	\part*{Więzy integralności}
  	
  	\section*{Skompilowane komendy (stored commands)}
  	\begin{itemize}
  		\item \textbf{SqlRetrieve} - dostejemy uchwyt i od razu tę komendę mamy.
  		\item Retrieve, jak nie to Store, jak nie to Prepare
  	\end{itemize}
  	\section*{Procedury bazy danych (stored procedures)}
  	\begin{itemize}
  		\item Procedura może nawet "zastąpić" SELECT (udawać go)
  		\item Dzielimy je na statyczne i dynamiczne (gdy zapytaniem jest np. zdanie SQL)
  		\item Parametry - wejściowe lub wyjściowe, te drugie oznaczamy jako RECEIVE, przy pierwszych nic nie jest wymagane (chyba).
  		\item Mają zmienne lokalne.
  		\item Sekcje: on procedure startup / execute / fetch / close
  		\item Może być fetchowalna - że można z niej fetch, fetch, fetch a potem daje EOF.
  	\end{itemize}
  	\section{Przykład}
  	\textbf{procedures}\\
  	type p1\\
  	type p2\\
  	receive type rp1\\
  	receive type rp2 // do pobrania wyników\\
  	receive type rp3\\\\
  	\textbf{Komenda}:\\
  	SELECT rp1, rp3\\
  	FROM proc pp\\
  	WHERE pp.p1 = zm AND pp.p2 = 7\\
  	INTO :wyn1, :wyn2\\\\
  	Procedura udaje tablicę - ON PROCEDUE FETCH - a każdym FETCHem da te wyniki (wyn1, wyn2).\\
  	Jeśli nie chcemy procedury fetchowalnej to ON PPROCEDURE pomijamy.\\
  	Jeżeli chcemy: ON PROCEDURE STARTUP - wykorzystany tylko raz na początku.
  	
  	
 	\section*{Mechanizmy wyzwalaczy (triggers)}
  	Na tablicy/na perspektywnie/na bazie.\\
  	Jest też trigger INSTEAD OF - wykona się trigger, nie odbędzie się operacja, która wywołała trigger
  	ORDER number - kolejność różnych triggerów dla tego samego zdarzenia.\\
  	\begin{itemize}
	  	\item FOR EACH STATEMENT - jeśli np. dla update, wykona się raz na update
	  	\item FOR EACH ROW - update na wielu wierszach - wywoła się dla każdego wiersza
	  	\item Trigger BEFORE - w kontekście wykonania sprzed modyfikacji tablicy
	  	\item AFTER - w kontekście wykonania po modyfikacji tablicy
  	\end{itemize}
  	[REFERENCING OLD AS alias1 NEW AS alias2]\\
  	Można odczytywać wartości z wiersza sprzed i po modyfikacji dla update.\\\\
  	Dziwne rzeczy, pobranie nazwy current usera do zmiennej: SELECT USER FROM systables WHERE tbname = 'SYSTABLES' INTO :strUser\\
  	W Oraclu jest: select user from dual - zwraca 1 wiersz - nazwę usera\\
  	Inne cuda: tworzenie identyfikatorów w oparciu o sekwencje - cuda wianki na kiju\\\\
  	External procedures - kolejne cuda, jakieś windowsowe rzeczy\\
  	Events - też cuda. Serwery mają coś takiego jak deamon czasu.
  	
  	
  	% ======================================================================
  	% === Fazy realizacji zapytania SQL
  	% ======================================================================
  	\part*{Fazy realizacji zapytania SQL}
  	\subsection*{Komendy}
  	\begin{itemize}
  		\item DML: INSERT, DELETE, UPDATE
  		\item DQL: SELECT
  		\item Wywoływane  z poziomu języka systemu Centura Builder lub SQLBase SPL (Storage Procedure Language)
  	\end{itemize}
  	\subsection*{Fazy}
  	\begin{itemize}
  		\item \textbf{Faza PREPARE}		% === PREPARE ===
  		\begin{itemize}
  			\item Przesłanie komendy do serwera
  			\item Analiza syntaktyczna
  			\item Sprawdzanie istnienia obiektów (tablice, perspektywy, kolumny)
  			\item Sprawdzenie uprawnień (poziom uprawnień do operowania na zawartościach tabel)
  			\item Podstawienia (np. zastąpienie perspektyw, synonimów)
  			\begin{itemize}
  				\item Pobranie statystyk z katalogu systemowego
  				\item Analiza możliwych ścieżek realizacji wyszukiwania (access path)
  				\item Wybór ścieżki o najniższym koszcie wykonania (SQL cost)
  			\end{itemize}
  			\item Tłumaczenie na ciąg wywołań wykonywalnych modułów
  		\end{itemize}
  		\item \textbf{Faza EXECUTE}		% === EXECUTE ===
  		\begin{itemize}
  			\item Wysłanie zmiennych wiążących (bind variables)
  			\item Wykonanie komendy (rozpoczęcie tworzenia zbioru \emph{result set})
  		\end{itemize}
  		\item \textbf{Faza FETCH}		% === FETCH ===
  		\begin{itemize}
  			\item pobieranie wierszy rozwiązania (każdy “FETCH” to pobranie wiersza ze zbioru \emph{result set})
  		\end{itemize}
  	\end{itemize}
  	\subsection*{Etapy przetwarzania}
  	\begin{enumerate}
  		% --- CONNECT
  		\item \textbf{BOOL SqlConnect (SqlHandle)}\\
  		Przykład:\\
  		Set SQLDatabase 	= ‘DEMO’\\
  		Set SQLUser  		= ‘SYSADM’\\
  		Set SQLPassword 	= ‘Haslo’\\
  		if SqlConnect (hsql)\\
  			
  		% --- PREPARE
  		\item \textbf{BOOL SqlPrepare (SqlHandle, String)}\\
  		Przykład:\\
  		if SqlPrepare (hsql, \\
	  	‘SELECT t1.a1, t1.a2, t2.b1 \\
  		FROM tablica1 t1, tablica2 t2\\
  		WHERE  t1.a4 = t2.b2 and t1.b3 = :bind\_var\\
  		INTO  :into\_var1, :into\_var2, :into\_var3 ‘)\\\\
  		\textbf{Zmienne}:
  		\begin{itemize}
  			\item \textit{bind\_var} – wpłyną na selekcję
  			\item \textit{into\_var} – do czego zwrócimy wyniki
  		\end{itemize}
  		\textbf{Działanie}:
  		\begin{itemize}
  			\item PREPARE służy do przygotowania instrukcji SQL.
  			\item W dynamicznym SQL instrukcje są tworzone w czasie wykonywania programu i przechowywane jako tekst w zmiennej znakowej.
  			\item Instrukcja PREPARE konwertuje zawartość zmiennej na instrukcję SQL. Można ją następnie wykonać instrukcją EXECUTE lub usunąć DEALLOCATE\\
  			Przykład:\\
  			PREPARE LOCAL instrukcjaBartka FROM :SQLInstrukcja1;\\
  			Przygotowana zostaje instrukcja o nazwie 'instrukcjaBartka' ze zmiennej znakowej 'SQLInstrukcja1', nie będzie ona widoczna dla innych instrukcji
  		\end{itemize}
  		
  		% --- EXECUTE
  		\item \textbf{BOOL SqlExecute (SqlHandle)}\\
  		Przykład:
  		if SqlExecute (hsql)
  		\begin{itemize}
  			\item Wysłanie zmiennych wiążących (bind variables)
  			\item Wykonanie komendy (rozpoczęcie tworzenia zbioru result set)
  			\item EXECUTE służy do wykonywania przygotowanej instrukcji SQL (stworzonej instrukcją PREPARE).\\
  			Przykład:\\
  			EXECUTE instrukcja1 USING :nazwa, :miejsce\_urodz INTO LOCAL deskryptor3;\\
  			Wykonywana jest instrukcja o nazwie 'instrukcja1', dwa parametry są przekazywane do lokalnego deskryptora o nazwie 'deskryptor3'.
  		\end{itemize}
  		
  		% --- FETCH NEXT
  		\item \textbf{BOOL SqlFetchNext (SqlHandle, Number) (SqlFetchPrevious , SqlFetchRow)}\\
  		Przykład:
  		if SqlFetchNext (hsql, nRet)
  		\begin{itemize}
  			\item Pobieranie wierszy rozwiązania (każdy “FETCH” to pobranie wiersza ze zbioru result-set)
  			\item Przesuwanie się w zbiorze rozwiązań (do góry i na dół)
  			\item FETCH umożliwia pobranie wierszy z otwartego kursora.
  			\item Wartości są umieszczane na specjalnej liście w uporządkowanej kolejności.\\
  			FETCH orientacja FROM nazwa INTO specyfikacja\_docelowa, ...
  			\item Kursor - obiekt używany do przechowywania wyników zapytania. Różni się od widoku tym iż nie zachowuje się jak tabela. Jest rodzajem zmiennej, przechowującej wyniki zapytania, aby można je później wykorzystać wiersz po wierszu.
  		\end{itemize}
  		SQL Base pracuje w trybie result-set – serwer w wyprzedzeniem podrzuca wiersze, które później mogą być potrzebne.\\
  		
  		\item \textbf{BOOL SqlDisconnect (SqlHandle)}\\
  		Przykład:
  		if SqlDisconnect (hsql)\\\\
  		Przykład 1:\\
  		if SqlPrepare (hSqlHandle, \\
  		‘UPDATE tablica1 \\
  		SET	a1 = @NOW,\\
  		a2 = :var1\\
  		a3 = :var2\\
  		WHERE\\
  		a4 = 1999-12-24\\
  		a5 = :var3’)\\
  		if SqlExecute (hSqlHandle)\\
  		if SqlCommit (hSqlHandle)\\\\
  		Przykład 2:\\\\
  		if SqlPrepareAndExecute (hSqlHandle, \\
  		‘INSERT INTO tablica1 \\
  		(a1, a2, a3, a4, a5, a6)\\
  		VALUES\\
  		(@NOW, ‘text’, 112, 1999-12-23, :var1, :var2)’)\\
  		if SqlImmediate (‘ROLLBACK’)
  	\end{enumerate}
  		
  	
  	% ===================================================================
  	% === ZARZĄDZANIE DOSTĘPEM
  	% ===================================================================
  	\part*{Zarządzanie dostępem}
  	
  	% --- Autoryzacja
  	\section*{Autoryzacja}
  	\begin{itemize}
  		\item Użytkownicy są identyfikowani przez nazwy i hasła 
  		\item Identyfikator \textbf{PUBLIC} używany jest do przyznania przywilejów dla wszystkich użytkowników
  	\end{itemize}
  	
  	% --- Poziomy uprawnień i róznice między nimi
  	\section*{Poziomy uprawnień i róznice między nimi}
  	\begin{itemize}
  		\item \textbf{SYSADM}
  		\begin{itemize}
  			\item Pełna kontrola nad całą bazą.
  			\item Potrafi wszytsko, zarządza użytkownikami, hasłami i poziomami uprzywilejowania.
  			\item Jest tylko jeden - nie można utworzyć nowych \emph{sysadmów}.
  			\item Jako jedyny może tworzyć nowych użytkowników.
  		\end{itemize}
  		\item \textbf{DBA}
  		\begin{itemize}
  			\item Pełny dostęp do bazy i wszystkich jej obiektów.
  			\item Zarządzanie przywilejami - może przyznawać i odbierać prawa do obiektów innym.
  		\end{itemize}
  		\item \textbf{RESOURCE}
  		\begin{itemize}
  			\item Tworzenie i usuwanie stworzonych przez siebie tablic.
  			\item Odbieranie i nadawanie praw do ww. tablic innym użytkownikom.
  		\end{itemize}
  		\item \textbf{CONNECT}
  		\begin{itemize}
  			\item Połączenie z bazą danych.
  			\item Operacje na tablicach do których ma odpowienie uprawnienia.
  			\item Dostęp tylko według przyznanych przywilejów.
  			\item Tworzenie synonimów.
  		\end{itemize}
  	\end{itemize}
  	
  	% --- Przywileje
  	\section*{Przywileje dostępu}
  	\begin{itemize}
  		\item Wyszukiwanie (\emph{SELECT}) 
  		\item Zmiana danych (\emph{INSERT}, \emph{DELETE}, \emph{UPDATE}), można określić dostęp do kolumn 
  		\item Zmiana struktury (\emph{ALTER}) 
  		\item Tworzenie i usuwanie indeksów (\emph{INDEX})
  		\item Właściciel tablicy ma do niej wszystkie prawa
  	\end{itemize}
  	
  	% --- Prawa do obiektów bazy danych
  	% === DO UZUPEŁNIENIA ==============
  	\section*{Nadawanie praw do obiektów bazy danych}
  	\begin{itemize}
  		\item Prawa można nadawać do obiektów bazy danych (tablica, perspektywa, procedura bazy danych)
  		\item Sposoby nadawania uprawnień do obiektów:
  		\begin{itemize}
  			\item \textbf{Poziom baz danych}\\
  			GRANT CONNECT TO $ < $\emph{ids}$ > $ IDENTIFIED BY $ < $\emph{pass}$ > $\\
  			GRANT {RESOURCE, DBA} TO $ < $\emph{ids}$ > $\\
  			REVOKE {CONNECT, 
  				RESOURCE, DBA} FROM  $ < $\emph{ids}$ > $\\\\
  			\textbf{Wynik:}\\
  			\begin{tabular}{|l|l|}
  				\hline
  				SYSADM\\
  				\hline
  				\textbf{DBA}\\
  				\hline
  				\textbf{RESOURCE}\\
  				\hline
  				\textbf{CONNECT}\\
  				\hline
  			\end{tabular}\\
  			\item \textbf{Poziom tablic i perspektyw}\\
  			GRANT  $ < $priv$ > $ ON $ < $tab/view$ > $ TO {$ < $ids$ > $, PUBLIC}\\
  			REVOKE $ < $priv$ > $ ON $ < $tab/view$ > $ FROM {$ < $ids$ > $, PUBLIC}\\\\
  			\textbf{Wynik:}\\
  			\begin{tabular}{|l|l|}
  				\hline \textbf{$ < $priv$ > $}\\
  				\hline ALL\\
  				\hline \textbf{SELECT}\\
  				\hline \textbf{INSERT}\\
  				\hline \textbf{DELETE}\\
  				\hline \textbf{INDEX}\\
  				\hline ALTER\\
  				\hline UPDATE [ (col) [,(col) .. ]]\\
  				\hline
  			\end{tabular}\\
  			\item \textbf{Przykrywanie poprzez synonimy}\\
  			CREATE PUBLIC SYNONYM nazwa FOR tabela / perspektywa\\
  			CREATE SYNONYM użytkownik.nazwa FOR tabela / perspektywa\\
  			\emph{Synonimy moga być publiczne i prywatne, pierwszeństwo mają synonimy \textbf{prywatne}}
  			\item Uprawnienia dla tablic przez perspektywy dla określonych użytkowników
  			\item Możliwość wykonywania procedur z prawami twórcy
  		\end{itemize}
  	\end{itemize}
  	
  	% --- Zabezpieczenie serwera
  	\section*{Zabezpieczenie serwera}
  	\begin{itemize}
  		\item Komenda \emph{SET SERVER nazwa\_serwera / hasło\_serwera} jest konieczna do wykonania operacji na serwerze:
  		\begin{itemize}
  			\item Backup i restore 
  			\item Tworzenie oraz kasowanie baz i dzienników 
  			\item Instalacja oraz deinstalacja bazy danych
  		\end{itemize}
  	\end{itemize}
  	
  	% --- Synonimy i perspektywy
  	\section*{Synonimy i perspektywy}
  	\begin{itemize}
  		\item Dla ułatwienia dostępu do obiektów utworzonych przez innego użytkownika można definiować synonimy poleceniem:
  		\center{\emph{CREATE} [\emph{PUBLIC}] \emph{SYNONYM} synonim \emph{FOR} uid.tabela}
  		\begin{itemize}
  			\item Istnienie publicznego synonimu nie oznacza publicznych praw dostępu! 
  			\item Do selektywnego udostępniania tabel można używać perspektyw, w przypadku przywilejów umożliwiających zmiany warto użyć perspektyw \emph{WITH CHECK OPTION}
  		\end{itemize}
  	\end{itemize}
  	
  	% --- Nadawanie i odbieranie przywilejów dostępu
  	\section*{Nadawanie i odbieranie przywilejów dostępu}
  	\subsection*{Do tablic i perspektyw}
  	\begin{itemize}
  		\item przywileje może nadawać i odbierać tylko właściciel, DBA lub SYSADM.
  		\item Można odebrać tylko przywileje nadane expilicite
  	\end{itemize}
  	
  	
  	% ==========================================================================
  	% === Sposoby zarządzania dostępem 
  	% ==========================================================================
  	\part*{Sposoby zarządzania dostępem}
  	
  	% --- SQL
  	\section*{W SQL}
  	\begin{itemize}
  		\item Tworzenie użytkowników i nadawanie poziomów dostępu\\\\
  		\centerline{\emph{GRANT CONNECT}|\emph{RESOURCE}|\emph{DBA TO} uid \emph{IDENTIFIED BY} passwd;}
  		\item Usuwanie użytkowników\\\\ \centerline{\emph{REVOKE CONNECT}|\emph{RESOURCE}|\emph{DBA FROM} uid;}
  		\item Przyznawanie przywilejów dostępu do tabeli lub\\\\ \centerline{\emph{GRANT ALL} | lista\_przywilejów \emph{ON} nazwa \emph{TO} uid | \emph{PUBLIC} }
  		\item Przywilej \emph{UPDATE} może dotyczyć tylko wybranych kolumn\\\\ \centerline{\emph{UPDATE} ( lista\_kolumn ) }
  		\item Odbieranie przywilejów\\\\ \centerline{\emph{REVOKE ALL} | lista\_przywilejów \emph{FROM} uid | \emph{PUBLIC}}
  		\item Użytkowników i przywileje można oglądać przez perspektywy:
  		\begin{itemize}
  			\item \emph{SYSUSERAUTH}
  			\item \emph{SYSTABAUTH}
  			\item \emph{SYSCOLAUTH}
  		\end{itemize}
  	\end{itemize}
  	
  	% --- Różnice pomiędzy modelem logicznym i fizycznym bazy danych
  	\section*{Różnice pomiędzy modelem logicznym i fizycznym bazy danych}
  	\subsection*{Model logiczny}	% --- model logiczny
  	\begin{itemize}
  		\item Zawiera encje i klucze pierwotne
  		\item Nie posiada kluczy obcych
  		\item Typy danych i identyfikatory są abstrakcyjne
  		\item Związek M:N
  		\item Brak struktur dodatkowych
  	\end{itemize}
  	\subsection*{Model fizyczny}	% --- model fizycznjy
  	\begin{itemize}
  		\item Konkretne tablice
  		\item Migracja kluczy obcych
  		\item Brak modelu M:N - powstaje dodatkowa tablica łączna
  		\item Identyfikatory zgodne z konkretnym serwerem
  	\end{itemize}
  	
  	% --- Różnice w dostępie do danych za pośrednictwem indeksów B+tree i cluster hashed w SQLBase
  	% === DO UZUPEŁNIENIA ==============
  	\section*{Różnice w dostępie do danych za pośrednictwem indeksów B+tree i cluster hashed w SQLBase}
  	\subsection*{Co to jest?}
  	\begin{itemize}
  		\item \textbf{Full scan} - przegląda wszystkie wiersze
  		\item \textbf{B+Tree} - dostęp przez drzewo indeksowe zrównoważone, liczba wyprowadzeń z liści nie jest stała
  		\item \textbf{Selekcja przez indeks} - ${h+1}$ odwołań
  		\item \textbf{Cluster hashed} - specyficzny sposób rozmieszczenia rekordów, przy tworzeniu tabeli podaje się liczbę wierszy w tabeli, przy 1.  insercie alokacja pustych stron w 1 kawałku
  		\item Np. RCNT 1000 -$ > $ 10 (liczba wierszy na stronie) -$ > $ PCNT 100
  	\end{itemize}
  	\subsection*{Pozostałe}
  	\begin{itemize}
  		\item Działanie optymalizatora "wybierającego" metodę dostępu na podstawie postaci predykatu w WHERE
  		\item Dla predykatu wycinającego ileś wierszy (np. Typu “$ < $” albo between) wybiera się index B+ jesli istnieje, bo jest szybszy (wchodzi się “do liści” i wycina odpowiednie poddrzewo z rozwiązaniami).
  		\item Wstawianie jest szybsze dla cluster hashed.
  	\end{itemize}
  	
  	
  	
  	%===============================================================================	
  	%*******************************************************************************
  	%===============================================================================
  \end{document}